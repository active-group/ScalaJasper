package de.ag.jrlang.core

import net.sf.jasperreports.{engine => jre}
import net.sf.jasperreports.engine.design.{JRDesignDataset, JRDesignParameter, JRDesignStyle}
import net.sf.jasperreports.engine.JRDatasetParameter
import de.ag.jrlang.core.Dimensions.Length
import java.util.{UUID, TimeZone, Locale}

// TODO: Abstraction over Map+Int?
case class TransformationState(containerWidth: Length, env: Map[AnyRef, JRDesignParameter], nextp: Int,
                               styles: Map[AbstractStyle, JRDesignStyle], nextst: Int,
                               datasets: Map[Dataset, JRDesignDataset], nextds: Int,
                               next_uuid: Int) {
  def binding(v : AnyRef) = {
    val o = env.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val id = nextp
      val name = "auto" + id
      val p = new JRDesignParameter()
      p.setName(name)
      // p.setValueClass is wrong, in that is results in the result of getName of the class to be inserted into Java
      // sourccode (a "bug" in Jasper). getCanonicalName would imho be closer to correctness, but unfortunately, most
      // classes generated by Scala simply do not have a name that can be used as the name of a class in Java
      // sourcecode (as Jasper generated type-cast expressions with this name). So, I don't know better than to use
      // Object for everything - there will be more type casts before usage of the value anyhow (to Function1 e.g.):
      // p.setValueClassName(if (v == null) "Object" else v.getClass.getName) // ok??
      // p.setValueClassName(v.getClass.getCanonicalName)
      p.setValueClassName("Object")
      (name, this.copy(env = env.updated(v, p), nextp = id+1))
    }
  }

  def styleName(v : AbstractStyle, f : TransformationState => (JRDesignStyle, TransformationState)) : (String, TransformationState) = {
    val o = styles.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val (s, st2) = f(this)
      val id = nextst
      val name = "auto" + id
      s.setName(name)
      (name, this.copy(styles = styles.updated(v, s), nextst = id+1))
    }
  }

  def datasetName(v : Dataset, f : TransformationState => (JRDesignDataset, TransformationState)) : (String, TransformationState) = {
    // TODO: remove code duplication with styleName (and binding)
    val o = datasets.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val (s, st2) = f(this)
      val id = nextst
      val name = "auto" + id
      s.setName(name)
      (name, this.copy(datasets = datasets.updated(v, s), nextds = id+1))
    }
  }

  def nextUUID : (UUID, TransformationState) = {
    // nameUUIDFromBytes uses MD5, so sequential numbers are 'mangled' anyway, so it should be ok
    val id = UUID.nameUUIDFromBytes(Array(
      ((next_uuid >>> 24) & 0xFF) toByte,
      ((next_uuid >>> 16) & 0xFF) toByte,
      ((next_uuid >>> 8) & 0xFF) toByte,
      (next_uuid & 0xFF) toByte
    ))
    (id, this.copy(next_uuid = next_uuid+1))
  }
}

object TransformationState {
  def initial(containerWidth: Length) = TransformationState(containerWidth, Map.empty, 0, Map.empty, 0, Map.empty, 0, 0)
}

trait Transformable[+A] {
  def transform : Transformer[A]
}

trait Transformer[+A] { self =>
  def exec(st: TransformationState) : (A, TransformationState)

  def >>=[B](f : (A => Transformer[B])) : Transformer[B] =
    new Transformer[B] {
      def exec(st0 : TransformationState) = {
        val (a, st1) = self.exec(st0)
        f(a).exec(st1)
      }
    }

  // would be nice to define this only for A = Unit, but how? This one might throw at runtime?
  //def >>[B](n : Transformer[B]) = this >>= { Unit => n }

}

/* trait FilterMonadic[+A, +Repr] {
abstract def flatMap[B, That](f: (A) ⇒ GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That
abstract def foreach[U](f: (A) ⇒ U): Unit
abstract def map[B, That](f: (A) ⇒ B)(implicit bf: CanBuildFrom[Repr, B, That]): That
abstract def withFilter(p: (A) ⇒ Boolean): FilterMonadic[A, Repr]
 */

trait ImperativeTransformer extends Transformer[Unit] {
  def >>[B](n : => Transformer[B]) = this >>= { _ => n }
}

object Transformer {
  /** a transformer that already has the desired result */
  def ret[B](v : B) : Transformer[B] = new Transformer[B] {
    def exec(st: TransformationState) = (v, st)
  }

  // this ensures >> is only called on Unit Transformers
  // well, maybe the runtime overhead is to much just to prevent code errors...?
  implicit def isImperative(t: Transformer[Unit]) : ImperativeTransformer = new ImperativeTransformer {
    def exec(st: TransformationState) = t.exec(st)
  }

  /** drops the result of a transformation into a matching setter function */
  def drop[B](t : Transformer[B])(set : B => Unit) : Transformer[Unit] =
    t >>= { b => set(b); ret() }

  def orNull[B <: AnyRef](o : Option[Transformer[B]]) : Transformer[B] =
    o.getOrElse(ret(null.asInstanceOf[B]))

  def all[B](l : Seq[Transformer[B]]) : Transformer[Seq[B]] =
    l.foldLeft(ret(Vector[B]())) {
      case (res, v) => v >>= { it => res >>= { lst => ret(lst :+ it) } }
    }

  /** creates a transformer that can also modify the transformation state */
  private def withState[A](f : TransformationState => (A, TransformationState)) : Transformer[A] =
    new Transformer[A] {
      def exec(st: TransformationState) = f(st)
    }

  private def getState : Transformer[TransformationState] = withState({ st => (st, st)})

  /** returns a parameter name for the given value */
  def binding(v : AnyRef) : Transformer[String] = withState({st => st.binding(v)})

  /** returns a name for the given style. If it's a new style, f is called, a new name assigned to the result and
      stored for later retrieval (when the report if transformed. */
  def styleName(v : AbstractStyle, f : () => Transformer[JRDesignStyle]) : Transformer[String] =
    withState({ st =>
      st.styleName(v, { st2 => f().exec(st2) }) // do we have to call exec?
    })

  /** returns a name for the given dataset. Like styleName */
  def datasetName(v : Dataset, f : () => Transformer[JRDesignDataset]) : Transformer[String] =
    withState({ st =>
      st.datasetName(v, { st2 => f().exec(st2) }) // do we have to call exec?
    })

  /** returns all automatic parameter (from environment) collected to far */
  def getCurrentEnvironment : Transformer[Map[AnyRef, JRDesignParameter]] =
    getState >>= { st => ret(st.env) }

  def withNewEnvironment[T](f : => Transformer[T]) : Transformer[T] =
    withState({previousState => {
      val newState = previousState.copy(env = Map.empty) // could reset id too
      val (res, _) = f.exec(newState) // modified state ignored, must be grabbed before end of f
      (res, previousState)
    }})

  def setCurrentContainerWidth(width: Length) : Transformer[Unit] =
    withState({ st => ((), st.copy(containerWidth = width)) })

  def currentContainerWidth : Transformer[Length] =
    getState >>= { st => ret(st.containerWidth) }

  def withContainerWidth[A](width: Length)(f : => Transformer[A]) : Transformer[A] =
    currentContainerWidth >>= {
      prev =>
        setCurrentContainerWidth(width) >> f >>= { res =>
          setCurrentContainerWidth(prev) >>
          ret(res)
        }
    }

  def nextUUID : Transformer[UUID] =
    withState({ st => st.nextUUID })
}

object Compiler {
  // The defaults for locale and timeZone are not the JVM's defaultLocale() etc values, because it's
  // hardly imaginable that your reports suddenly translate automatically into another language, or that you want them
  // to look different depending on the OS settings of a user; so it's better (also for testing) to have a stable
  // default that makes you aware of the need to adjust it. As for the timezone - it probably should not be used at
  // all, but I haven't found out yet (except it appears in the xml print)
  def compile(o : Report,
              locale : Locale = Locale.US,
              timeZone : TimeZone = TimeZone.getTimeZone("GMT") ) : (jre.JasperReport, Map[String, AnyRef]) = {
    // basic object generation...
    // TODO: Create sequential or pseudo-random UUIDs for all elements (and other?) - to simplify testing
    val (r, tstate) = o.transform.exec(TransformationState.initial(0 px))

    // now insert collected auto-generated properties into basic object

    // environment = parameters + arguments
    tstate.env foreach { case(_, p) => r.addParameter(p) }
    val envArgs = tstate.env map { case(v, p) => (p.getName, v) }

    // styles
    tstate.styles foreach { case (_, s) => r.addStyle(s) }

    // datasets, also add all auto-parameters to the subdatasets - they might have been used there too
    tstate.datasets foreach { case (_, ds) =>
      tstate.env foreach { case(_, p) => ds.addParameter(p) }
      r.addDataset(ds)
    }
    // override some things where Jasper will set unpleasant defaults
    val defaultArgs = Map(
      "REPORT_LOCALE" -> Locale.US,
      "REPORT_TIME_ZONE" -> TimeZone.getTimeZone("GMT")
      // TODO? add this and remove 'resourceBundle' from Report? "REPORT_RESOURCE_BUNDLE"
      // TODO? add IS_IGNORE_PAGINATION and remove from report? or maybe add to print() - it's a printing and not a report property anyway, isn't it?
      // some more...?
    )

    val finalreport = jre.JasperCompileManager.compileReport(r)
    (finalreport, defaultArgs ++ envArgs)
  }



}
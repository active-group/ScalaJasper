package de.ag.jrlang.core

import net.sf.jasperreports.{engine => jre}
import net.sf.jasperreports.engine.design.{JRDesignDataset, JRDesignParameter, JRDesignStyle}
import net.sf.jasperreports.engine.JRDatasetParameter

// TODO: Abstraction over Map+Int?
case class TransformationState(env: Map[AnyRef, JRDesignParameter], nextp: Int,
                               styles: Map[AbstractStyle, JRDesignStyle], nextst: Int,
                               datasets: Map[Dataset, JRDesignDataset], nextds: Int) {
  def binding(v : AnyRef) = {
    val o = env.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val id = nextp
      val name = "auto" + id
      val p = new JRDesignParameter()
      p.setName(name)
      // p.setValueClass is wrong, in that is results in the result of getName of the class to be inserted into Java
      // sourccode (a "bug" in Jasper). getCanonicalName would imho be closer to correctness, but unfortunately, most
      // classes generated by Scala simply do not have a name that can be used as the name of a class in Java
      // sourcecode (as Jasper generated type-cast expressions with this name). So, I don't know better than to use
      // Object for everything - there will be more type casts before usage of the value anyhow (to Function1 e.g.):
      // p.setValueClassName(if (v == null) "Object" else v.getClass.getName) // ok??
      // p.setValueClassName(v.getClass.getCanonicalName)
      p.setValueClassName("Object")
      (name, this.copy(env = env.updated(v, p), nextp = id+1))
    }
  }

  def styleName(v : AbstractStyle, f : TransformationState => (JRDesignStyle, TransformationState)) : (String, TransformationState) = {
    val o = styles.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val (s, st2) = f(this)
      val id = nextst
      val name = "auto" + id
      s.setName(name)
      (name, this.copy(styles = styles.updated(v, s), nextst = id+1))
    }
  }

  def datasetName(v : Dataset, f : TransformationState => (JRDesignDataset, TransformationState)) : (String, TransformationState) = {
    // TODO: remove code duplication with styleName (and binding)
    val o = datasets.get(v)
    if (o.isDefined)
      (o.get.getName, this)
    else {
      val (s, st2) = f(this)
      val id = nextst
      val name = "auto" + id
      s.setName(name)
      (name, this.copy(datasets = datasets.updated(v, s), nextds = id+1))
    }
  }
}

object TransformationState {
  val empty = TransformationState(Map.empty, 0, Map.empty, 0, Map.empty, 0)
}

trait Transformable[+A] {
  def transform : Transformer[A]
}

trait Transformer[+A] { self =>
  def exec(st: TransformationState) : (A, TransformationState)

  def >>=[B](f : (A => Transformer[B])) : Transformer[B] =
    new Transformer[B] {
      def exec(st0 : TransformationState) = {
        val (a, st1) = self.exec(st0)
        f(a).exec(st1)
      }
    }

  // would be nice to define this only for A = Unit, but how? This one might throw at runtime?
  //def >>[B](n : Transformer[B]) = this >>= { Unit => n }

}

/* trait FilterMonadic[+A, +Repr] {
abstract def flatMap[B, That](f: (A) ⇒ GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That
abstract def foreach[U](f: (A) ⇒ U): Unit
abstract def map[B, That](f: (A) ⇒ B)(implicit bf: CanBuildFrom[Repr, B, That]): That
abstract def withFilter(p: (A) ⇒ Boolean): FilterMonadic[A, Repr]
 */

trait ImperativeTransformer extends Transformer[Unit] {
  def >>[B](n : => Transformer[B]) = this >>= { _ => n }
}

object Transformer {
  /** a transformer that already has the desired result */
  def ret[B](v : B) : Transformer[B] = new Transformer[B] {
    def exec(st: TransformationState) = (v, st)
  }

  // this ensures >> is only called on Unit Transformers
  // well, maybe the runtime overhead is to much just to prevent code errors...?
  implicit def isImperative(t: Transformer[Unit]) : ImperativeTransformer = new ImperativeTransformer {
    def exec(st: TransformationState) = t.exec(st)
  }

  /** drops the result of a transformation into a matching setter function */
  def drop[B](t : Transformer[B])(set : B => Unit) : Transformer[Unit] =
    t >>= { b => set(b); ret() }

  def orNull[B <: AnyRef](o : Option[Transformer[B]]) : Transformer[B] =
    o.getOrElse(ret(null.asInstanceOf[B]))

  def all[B](l : Seq[Transformer[B]]) : Transformer[Seq[B]] =
    l.foldLeft(ret(Vector[B]())) {
      case (res, v) => v >>= { it => res >>= { lst => ret(lst :+ it) } }
    }

  /** creates a transformer that can also modify the transformation state */
  private def withState[A](f : TransformationState => (A, TransformationState)) : Transformer[A] =
    new Transformer[A] {
      def exec(st: TransformationState) = f(st)
    }

  /** returns a parameter name for the given value */
  def binding(v : AnyRef) : Transformer[String] = withState({st => st.binding(v)})

  /** returns a name for the given style. If it's a new style, f is called, a new name assigned to the result and
      stored for later retrieval (when the report if transformed. */
  def styleName(v : AbstractStyle, f : () => Transformer[JRDesignStyle]) : Transformer[String] =
    withState({ st =>
      st.styleName(v, { st2 => f().exec(st2) }) // do we have to call exec?
    })

  /** returns a name for the given dataset. Like styleName */
  def datasetName(v : Dataset, f : () => Transformer[JRDesignDataset]) : Transformer[String] =
    withState({ st =>
      st.datasetName(v, { st2 => f().exec(st2) }) // do we have to call exec?
    })

  /** returns all automatic parameter (from environment) collected to far */
  def getCurrentEnvironment : Transformer[Map[AnyRef, JRDesignParameter]] =
    withState({ st =>
      (st.env, st)
    })

  def withNewEnvironment[T](f : => Transformer[T]) : Transformer[T] =
    withState({previousState => {
      val newState = previousState.copy(env = Map.empty) // could reset id too
      val (res, _) = f.exec(newState) // modified state ignored, must be grabbed before end of f
      (res, previousState)
    }})
}

object Compiler {
  implicit def compile(o : Report) : (jre.JasperReport, Map[String, AnyRef]) = {
    // basic object generation...
    val (r, tstate) = o.transform.exec(TransformationState.empty)

    // now insert collected auto-generated properties into basic object

    // environment = parameters + arguments
    tstate.env foreach { case(_, p) => r.addParameter(p) }
    val envArgs = tstate.env map { case(v, p) => (p.getName, v) }

    // styles
    tstate.styles foreach { case (_, s) => r.addStyle(s) }

    // datasets, also add all auto-parameters to the subdatasets - they might have been used there too
    tstate.datasets foreach { case (_, ds) =>
      tstate.env foreach { case(_, p) => ds.addParameter(p) }
      r.addDataset(ds)
    }

    val finalreport = jre.JasperCompileManager.compileReport(r)
    (finalreport, envArgs)
  }



}